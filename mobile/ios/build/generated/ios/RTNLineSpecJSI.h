/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


#pragma mark - NativeLineLoginBotPrompt

enum class NativeLineLoginBotPrompt { Aggressive, Normal };

template <>
struct Bridging<NativeLineLoginBotPrompt> {
  static NativeLineLoginBotPrompt fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "aggressive") {
      return NativeLineLoginBotPrompt::Aggressive;
    } else if (value == "normal") {
      return NativeLineLoginBotPrompt::Normal;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeLineLoginBotPrompt");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeLineLoginBotPrompt value) {
    if (value == NativeLineLoginBotPrompt::Aggressive) {
      return bridging::toJs(rt, "aggressive");
    } else if (value == NativeLineLoginBotPrompt::Normal) {
      return bridging::toJs(rt, "normal");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeLineLoginBotPrompt");
    }
  }
};

#pragma mark - NativeLineLoginLoginPermission

enum class NativeLineLoginLoginPermission { Email, OpenId, Profile };

template <>
struct Bridging<NativeLineLoginLoginPermission> {
  static NativeLineLoginLoginPermission fromJs(jsi::Runtime &rt, const jsi::String &rawValue) {
    std::string value = rawValue.utf8(rt);
    if (value == "email") {
      return NativeLineLoginLoginPermission::Email;
    } else if (value == "openid") {
      return NativeLineLoginLoginPermission::OpenId;
    } else if (value == "profile") {
      return NativeLineLoginLoginPermission::Profile;
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for value in NativeLineLoginLoginPermission");
    }
  }

  static jsi::String toJs(jsi::Runtime &rt, NativeLineLoginLoginPermission value) {
    if (value == NativeLineLoginLoginPermission::Email) {
      return bridging::toJs(rt, "email");
    } else if (value == NativeLineLoginLoginPermission::OpenId) {
      return bridging::toJs(rt, "openid");
    } else if (value == NativeLineLoginLoginPermission::Profile) {
      return bridging::toJs(rt, "profile");
    } else {
      throw jsi::JSError(rt, "No appropriate enum member found for enum value in NativeLineLoginLoginPermission");
    }
  }
};
  
#pragma mark - NativeLineLoginAccessToken

template <typename P0, typename P1, typename P2>
struct NativeLineLoginAccessToken {
  P0 accessToken;
  P1 expiresIn;
  P2 idToken;
  bool operator==(const NativeLineLoginAccessToken &other) const {
    return accessToken == other.accessToken && expiresIn == other.expiresIn && idToken == other.idToken;
  }
};

template <typename T>
struct NativeLineLoginAccessTokenBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.accessToken)>(rt, value.getProperty(rt, "accessToken"), jsInvoker),
      bridging::fromJs<decltype(types.expiresIn)>(rt, value.getProperty(rt, "expiresIn"), jsInvoker),
      bridging::fromJs<decltype(types.idToken)>(rt, value.getProperty(rt, "idToken"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String accessTokenToJs(jsi::Runtime &rt, decltype(types.accessToken) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String expiresInToJs(jsi::Runtime &rt, decltype(types.expiresIn) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String idTokenToJs(jsi::Runtime &rt, decltype(types.idToken) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "accessToken", bridging::toJs(rt, value.accessToken, jsInvoker));
    result.setProperty(rt, "expiresIn", bridging::toJs(rt, value.expiresIn, jsInvoker));
    if (value.idToken) {
      result.setProperty(rt, "idToken", bridging::toJs(rt, value.idToken.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLineLoginFriendshipStatus

template <typename P0>
struct NativeLineLoginFriendshipStatus {
  P0 friendFlag;
  bool operator==(const NativeLineLoginFriendshipStatus &other) const {
    return friendFlag == other.friendFlag;
  }
};

template <typename T>
struct NativeLineLoginFriendshipStatusBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.friendFlag)>(rt, value.getProperty(rt, "friendFlag"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static bool friendFlagToJs(jsi::Runtime &rt, decltype(types.friendFlag) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "friendFlag", bridging::toJs(rt, value.friendFlag, jsInvoker));
    return result;
  }
};



#pragma mark - NativeLineLoginLoginParams

template <typename P0, typename P1, typename P2>
struct NativeLineLoginLoginParams {
  P0 botPrompt;
  P1 onlyWebLogin;
  P2 scopes;
  bool operator==(const NativeLineLoginLoginParams &other) const {
    return botPrompt == other.botPrompt && onlyWebLogin == other.onlyWebLogin && scopes == other.scopes;
  }
};

template <typename T>
struct NativeLineLoginLoginParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.botPrompt)>(rt, value.getProperty(rt, "botPrompt"), jsInvoker),
      bridging::fromJs<decltype(types.onlyWebLogin)>(rt, value.getProperty(rt, "onlyWebLogin"), jsInvoker),
      bridging::fromJs<decltype(types.scopes)>(rt, value.getProperty(rt, "scopes"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String botPromptToJs(jsi::Runtime &rt, decltype(types.botPrompt) value) {
    return bridging::toJs(rt, value);
  }

  static bool onlyWebLoginToJs(jsi::Runtime &rt, decltype(types.onlyWebLogin) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Array scopesToJs(jsi::Runtime &rt, decltype(types.scopes) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.botPrompt) {
      result.setProperty(rt, "botPrompt", bridging::toJs(rt, value.botPrompt.value(), jsInvoker));
    }
    if (value.onlyWebLogin) {
      result.setProperty(rt, "onlyWebLogin", bridging::toJs(rt, value.onlyWebLogin.value(), jsInvoker));
    }
    if (value.scopes) {
      result.setProperty(rt, "scopes", bridging::toJs(rt, value.scopes.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLineLoginLoginResult

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeLineLoginLoginResult {
  P0 accessToken;
  P1 friendshipStatusChanged;
  P2 idTokenNonce;
  P3 scope;
  P4 userProfile;
  bool operator==(const NativeLineLoginLoginResult &other) const {
    return accessToken == other.accessToken && friendshipStatusChanged == other.friendshipStatusChanged && idTokenNonce == other.idTokenNonce && scope == other.scope && userProfile == other.userProfile;
  }
};

template <typename T>
struct NativeLineLoginLoginResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.accessToken)>(rt, value.getProperty(rt, "accessToken"), jsInvoker),
      bridging::fromJs<decltype(types.friendshipStatusChanged)>(rt, value.getProperty(rt, "friendshipStatusChanged"), jsInvoker),
      bridging::fromJs<decltype(types.idTokenNonce)>(rt, value.getProperty(rt, "idTokenNonce"), jsInvoker),
      bridging::fromJs<decltype(types.scope)>(rt, value.getProperty(rt, "scope"), jsInvoker),
      bridging::fromJs<decltype(types.userProfile)>(rt, value.getProperty(rt, "userProfile"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::Object accessTokenToJs(jsi::Runtime &rt, decltype(types.accessToken) value) {
    return bridging::toJs(rt, value);
  }

  static bool friendshipStatusChangedToJs(jsi::Runtime &rt, decltype(types.friendshipStatusChanged) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String idTokenNonceToJs(jsi::Runtime &rt, decltype(types.idTokenNonce) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String scopeToJs(jsi::Runtime &rt, decltype(types.scope) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object userProfileToJs(jsi::Runtime &rt, decltype(types.userProfile) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "accessToken", bridging::toJs(rt, value.accessToken, jsInvoker));
    if (value.friendshipStatusChanged) {
      result.setProperty(rt, "friendshipStatusChanged", bridging::toJs(rt, value.friendshipStatusChanged.value(), jsInvoker));
    }
    if (value.idTokenNonce) {
      result.setProperty(rt, "idTokenNonce", bridging::toJs(rt, value.idTokenNonce.value(), jsInvoker));
    }
    result.setProperty(rt, "scope", bridging::toJs(rt, value.scope, jsInvoker));
    if (value.userProfile) {
      result.setProperty(rt, "userProfile", bridging::toJs(rt, value.userProfile.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLineLoginSetupParams

template <typename P0, typename P1>
struct NativeLineLoginSetupParams {
  P0 channelId;
  P1 universalLinkUrl;
  bool operator==(const NativeLineLoginSetupParams &other) const {
    return channelId == other.channelId && universalLinkUrl == other.universalLinkUrl;
  }
};

template <typename T>
struct NativeLineLoginSetupParamsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.channelId)>(rt, value.getProperty(rt, "channelId"), jsInvoker),
      bridging::fromJs<decltype(types.universalLinkUrl)>(rt, value.getProperty(rt, "universalLinkUrl"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String channelIdToJs(jsi::Runtime &rt, decltype(types.channelId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String universalLinkUrlToJs(jsi::Runtime &rt, decltype(types.universalLinkUrl) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "channelId", bridging::toJs(rt, value.channelId, jsInvoker));
    if (value.universalLinkUrl) {
      result.setProperty(rt, "universalLinkUrl", bridging::toJs(rt, value.universalLinkUrl.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeLineLoginUserProfile

template <typename P0, typename P1, typename P2, typename P3>
struct NativeLineLoginUserProfile {
  P0 displayName;
  P1 pictureUrl;
  P2 statusMessage;
  P3 userId;
  bool operator==(const NativeLineLoginUserProfile &other) const {
    return displayName == other.displayName && pictureUrl == other.pictureUrl && statusMessage == other.statusMessage && userId == other.userId;
  }
};

template <typename T>
struct NativeLineLoginUserProfileBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.displayName)>(rt, value.getProperty(rt, "displayName"), jsInvoker),
      bridging::fromJs<decltype(types.pictureUrl)>(rt, value.getProperty(rt, "pictureUrl"), jsInvoker),
      bridging::fromJs<decltype(types.statusMessage)>(rt, value.getProperty(rt, "statusMessage"), jsInvoker),
      bridging::fromJs<decltype(types.userId)>(rt, value.getProperty(rt, "userId"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String displayNameToJs(jsi::Runtime &rt, decltype(types.displayName) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String pictureUrlToJs(jsi::Runtime &rt, decltype(types.pictureUrl) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String statusMessageToJs(jsi::Runtime &rt, decltype(types.statusMessage) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String userIdToJs(jsi::Runtime &rt, decltype(types.userId) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "displayName", bridging::toJs(rt, value.displayName, jsInvoker));
    if (value.pictureUrl) {
      result.setProperty(rt, "pictureUrl", bridging::toJs(rt, value.pictureUrl.value(), jsInvoker));
    }
    if (value.statusMessage) {
      result.setProperty(rt, "statusMessage", bridging::toJs(rt, value.statusMessage.value(), jsInvoker));
    }
    result.setProperty(rt, "userId", bridging::toJs(rt, value.userId, jsInvoker));
    return result;
  }
};



#pragma mark - NativeLineLoginVerifyResult

template <typename P0, typename P1, typename P2>
struct NativeLineLoginVerifyResult {
  P0 clientId;
  P1 expiresIn;
  P2 scope;
  bool operator==(const NativeLineLoginVerifyResult &other) const {
    return clientId == other.clientId && expiresIn == other.expiresIn && scope == other.scope;
  }
};

template <typename T>
struct NativeLineLoginVerifyResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.clientId)>(rt, value.getProperty(rt, "clientId"), jsInvoker),
      bridging::fromJs<decltype(types.expiresIn)>(rt, value.getProperty(rt, "expiresIn"), jsInvoker),
      bridging::fromJs<decltype(types.scope)>(rt, value.getProperty(rt, "scope"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String clientIdToJs(jsi::Runtime &rt, decltype(types.clientId) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String expiresInToJs(jsi::Runtime &rt, decltype(types.expiresIn) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String scopeToJs(jsi::Runtime &rt, decltype(types.scope) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "clientId", bridging::toJs(rt, value.clientId, jsInvoker));
    result.setProperty(rt, "expiresIn", bridging::toJs(rt, value.expiresIn, jsInvoker));
    result.setProperty(rt, "scope", bridging::toJs(rt, value.scope, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeLineLoginCxxSpecJSI : public TurboModule {
protected:
  NativeLineLoginCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getCurrentAccessToken(jsi::Runtime &rt) = 0;
  virtual jsi::Value getFriendshipStatus(jsi::Runtime &rt) = 0;
  virtual jsi::Value getProfile(jsi::Runtime &rt) = 0;
  virtual jsi::Value login(jsi::Runtime &rt, jsi::Object params) = 0;
  virtual jsi::Value logout(jsi::Runtime &rt) = 0;
  virtual jsi::Value refreshAccessToken(jsi::Runtime &rt) = 0;
  virtual jsi::Value setup(jsi::Runtime &rt, jsi::Object params) = 0;
  virtual jsi::Value verifyAccessToken(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeLineLoginCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "LineLogin";

protected:
  NativeLineLoginCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeLineLoginCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeLineLoginCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeLineLoginCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value getCurrentAccessToken(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getCurrentAccessToken) == 1,
          "Expected getCurrentAccessToken(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCurrentAccessToken, jsInvoker_, instance_);
    }
    jsi::Value getFriendshipStatus(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getFriendshipStatus) == 1,
          "Expected getFriendshipStatus(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getFriendshipStatus, jsInvoker_, instance_);
    }
    jsi::Value getProfile(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getProfile) == 1,
          "Expected getProfile(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getProfile, jsInvoker_, instance_);
    }
    jsi::Value login(jsi::Runtime &rt, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::login) == 2,
          "Expected login(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::login, jsInvoker_, instance_, std::move(params));
    }
    jsi::Value logout(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::logout) == 1,
          "Expected logout(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::logout, jsInvoker_, instance_);
    }
    jsi::Value refreshAccessToken(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::refreshAccessToken) == 1,
          "Expected refreshAccessToken(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::refreshAccessToken, jsInvoker_, instance_);
    }
    jsi::Value setup(jsi::Runtime &rt, jsi::Object params) override {
      static_assert(
          bridging::getParameterCount(&T::setup) == 2,
          "Expected setup(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setup, jsInvoker_, instance_, std::move(params));
    }
    jsi::Value verifyAccessToken(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::verifyAccessToken) == 1,
          "Expected verifyAccessToken(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::verifyAccessToken, jsInvoker_, instance_);
    }

  private:
    friend class NativeLineLoginCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
